### 算法题解题思路

1. 双指针法：适用于数组

   - 同向：两个指针(i,j)初始化可以指向头或者尾，初始位置-->i（该段为目标内容），i-->j（该段为检测后不符合条件内容），j-->末尾（该段为未检测内容），这种方式处理过的内容相对位置一致

     ```go
     /***
     通用步骤：
     1.初始化两个指针，使其指向0索引
     2.while j<arr.length
     	需要j索引的值就将j索引的值与i索引的值交换，并移动i指针
     	不需要j索引的值就跳过，不移动i
     */
     
     
     //给定一个数组[1,2,0,3,0,8]，将0移动到最后，要求结果为[1,2,3,8,0,0]
     var arr = [6]int{1, 2, 0, 3, 0, 8}
     i, j := 0, 0
     for ; j < len(arr); j++ {
     	if arr[j] != 0 {
     		arr[i], arr[j] = arr[j], arr[i]
     		i++
     	}
     }
     fmt.Println(arr)
     ```

     

   - 反向：两个指针(i,j)初始化分别指向头和尾部，开始-->i（该段为处理过的数据），i-->j（该段为未处理过的数据），j-->末尾（该段为处理过的数据），这种方式处理过内容相对位置不一致

     ```go
     /**
     注意：必须保证至少一个指针在移动
     通用步骤：
     1.初始化两个指针，i=0,j=arr.length-1
     2.while i<=j
     	决定是移动i还是移动j（i是++，j是--），如果i索引值满足条件就移动i，如果j索引值满足条件就移动j
     	如果两个索引值都不满足条件，移动j
     */
     
     //给定一个数组[1,2,0,3,0,8]，将0移动到最后，要求结果可以相对位置不一致
     arr := [6]int{1, 2, 0, 3, 0, 8}
     i, j := 0, len(arr)-1
     for {
     	if i < j {
     		if arr[i] != 0 {
     			i++
     		} else if arr[j] != 0 {
     			arr[i], arr[j] = arr[j], arr[i]
     			j--
     		} else {
     			j--
     		}
     	} else {
     		break
     	}
     }
     fmt.Println(arr)
     ```

     

2. 二分查找：适用于排好序的数组

